#include "/Engine/Public/Platform.ush"
#include "MarchingCubesComputeShader.ush"

struct FTriangle
{
	float3 vert1;
	float3 vert2;
	float3 vert3;
};

struct FGridCell
{
	float3 positions[8];
	float values[8];
};

// Perform marching cubes on a subsection of the data grid
//globallycoherent AppendStructuredBuffer<FTriangle> outputTriangles;
globallycoherent RWBuffer<float3> outputVertexTriplets;
globallycoherent uint vertexTripletIndex = 0;

Buffer<float> dataGridValues;
uint3 gridPointCount;
float3 gridSizePerCube;
float3 zeroNodeOffset;

float isovalue;

bool IsValidIndex(uint x, uint y, uint z)
{
	if (x < 0 || x >= gridPointCount.x)
		return false;
	if (y < 0 || y >= gridPointCount.y)
		return false;
	if (z < 0 || z >= gridPointCount.z)
		return false;
	
	return true;
}

bool IsValidIndex(uint3 coord)
{
	return IsValidIndex(coord.x, coord.y, coord.z);
}

// Convert 3D coordinates into the single array index using little-endian notation
uint GetArrayIndex(uint x, uint y, uint z)
{
	if (x >= gridPointCount.x || y >= gridPointCount.y || z >= gridPointCount.z) 
	{
		return -1;
	}

	uint xComponent = x;
	uint yComponent = y * gridPointCount.x;
	uint zComponent = z * gridPointCount.x * gridPointCount.y;
	return zComponent + yComponent + xComponent;
}

uint GetArrayIndex(uint3 coord)
{
	return GetArrayIndex(coord.x, coord.y, coord.z);
}

/// Convert internal array reference into grid coordinates
uint3 GetGridReference(uint index)
{
	uint x = index % gridPointCount.x;
	uint y = (index / gridPointCount.x) % gridPointCount.y;
	uint z = (index / (gridPointCount.x * gridPointCount.y)) % gridPointCount.z;
	return uint3(x, y, z);
}

uint CalculateCubeIndex(FGridCell gridCell)
{
    uint cubeIndex = 0;
    for (uint i = 0; i < 8; i++)
    {
        if (gridCell.values[i] > isovalue)
            cubeIndex |= (1 << i);
    }
    return cubeIndex;
}

float3 InterpolateEdge(float3 vec1, float3 vec2, float val1, float val2)
{
	if (abs(val1 - isovalue) < 1e-5)
		return vec1.xyz;
	if (abs(val2 - isovalue) < 1e-5)
		return vec2.xyz;
	if (abs(val1 - val2) < 1e-5)
		return vec1.xyz;
	
	float interpolant = (isovalue - val1) / (val2 - val1);
	interpolant = clamp(interpolant, 0, 1);
	return vec1.xyz + interpolant * (vec2.xyz - vec1.xyz);
}

[numthreads(THREADS_X, THREADS_Y, THREADS_Z)]
void MarchingCubesComputeShader(
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint GroupIndex : SV_GroupIndex )
{
	// Determine which grid cell should be calculated
	uint3 gridCellToBeTriangulated = DispatchThreadId;
	// Check whether this is a valid grid cell and return if not
	if (!IsValidIndex(gridCellToBeTriangulated))
	{
		return;
	}
	
	// Create the gridCell
	FGridCell gridCell;
	for (uint i = 0; i < 8; i++)
	{
		uint3 workingCoordinate = gridCellToBeTriangulated + vertexOrder[i];
		gridCell.positions[i] = zeroNodeOffset + float3(workingCoordinate.x * gridSizePerCube.x, workingCoordinate.y * gridSizePerCube.y, workingCoordinate.z * gridSizePerCube.z);
		gridCell.values[i] = dataGridValues[GetArrayIndex(workingCoordinate)];
	}
	
	// Calculate the unique cube index
    uint cubeIndex = CalculateCubeIndex(gridCell);
	
	// Check if the cube configuration requires any triangles
    if (edgeTable[cubeIndex] == 0)
        return;
	
	// Interpolate the required vertices
    float3 interpolatedVertices[12];
	// Iterate over the 12 edges of the cube
	// If the surface does cross this edge, find the interpolation point, otherwise write a zero vector
    for (uint i = 0; i < 12; i++)
    {
        if (edgeTable[cubeIndex] & 1 << i)
        {
            int2 vertices = verticesOnEdge[i];
            float3 interpolatedPoint = InterpolateEdge(gridCell.positions[vertices.x], gridCell.positions[vertices.y], gridCell.values[vertices.x], gridCell.values[vertices.y]);
            interpolatedVertices[i] = interpolatedPoint;
        }
        else
        {
			// This edge will not be used in calculations, so pad the list with zero vector
            interpolatedVertices[i] = float3(0, 0, 0);
        }
    }
	
	// Generate the required triangles
	// Each triad of vertices on the triTable represent a valid triangle for this cube index
	// Iterate over the triangles and add them to the total list of needed triangles
    for (uint i = 0; triTable[cubeIndex][i] != -1; i += 3)
    {
		// Method 1 using tri structs
        //FTriangle tri;
        //tri.vert1 = interpolatedVertices[triTable[cubeIndex][i]];
        //tri.vert2 = interpolatedVertices[triTable[cubeIndex][i + 1]];
        //tri.vert3 = interpolatedVertices[triTable[cubeIndex][i + 2]];
        //outputTriangles.Append(tri);
		
		// Method 2 returning triplets of vertices
        uint designatedIndex;
        InterlockedAdd(vertexTripletIndex, 3, designatedIndex);
        outputVertexTriplets[designatedIndex] = interpolatedVertices[triTable[cubeIndex][i]];
        outputVertexTriplets[designatedIndex + 1] = interpolatedVertices[triTable[cubeIndex][i + 1]];
        outputVertexTriplets[designatedIndex + 2] = interpolatedVertices[triTable[cubeIndex][i + 2]];
    }
}

