#include "/Engine/Public/Platform.ush"
#include "MarchingCubesComputeShader.ush"

struct FTriangle
{
	float3 vert1;
	float3 vert2;
	float3 vert3;
};

struct FGridCell
{
	float3 positions[8];
	float values[8];
};

// Perform marching cubes on a subsection of the data grid
globallycoherent AppendStructuredBuffer<FTriangle> outputTriangles;
uint vertexTripletIndex = 0;

Buffer<float> dataGridValues;
uint3 gridPointCount;
float3 gridSizePerCube;
float3 zeroNodeOffset;

float isovalue;

bool IsValidIndex(uint x, uint y, uint z)
{
	if (x < 0 || x >= gridPointCount.x)
		return false;
	if (y < 0 || y >= gridPointCount.y)
		return false;
	if (z < 0 || z >= gridPointCount.z)
		return false;
	
	return true;
}

bool IsValidIndex(uint3 coord)
{
	return IsValidIndex(coord.x, coord.y, coord.z);
}

// Convert 3D coordinates into the single array index using little-endian notation
uint GetArrayIndex(uint x, uint y, uint z)
{
	if (x >= gridPointCount.x || y >= gridPointCount.y || z >= gridPointCount.z) 
	{
		return -1;
	}

	uint xComponent = x;
	uint yComponent = y * gridPointCount.x;
	uint zComponent = z * gridPointCount.x * gridPointCount.y;
	return zComponent + yComponent + xComponent;
}

uint GetArrayIndex(uint3 coord)
{
	return GetArrayIndex(coord.x, coord.y, coord.z);
}

/// Convert internal array reference into grid coordinates
uint3 GetGridReference(uint index)
{
	uint x = index % gridPointCount.x;
	uint y = (index / gridPointCount.x) % gridPointCount.y;
	uint z = (index / (gridPointCount.x * gridPointCount.y)) % gridPointCount.z;
	return uint3(x, y, z);
}

uint CalculateCubeIndex(FGridCell gridCell)
{
    uint cubeIndex = 0;
    for (uint i = 0; i < 8; i++)
    {
        if (gridCell.values[i] > isovalue)
            cubeIndex |= (1 << i);
    }
    return cubeIndex;
}

float3 InterpolateVertices(float4 vec1, float4 vec2)
{
	if (abs(vec1.w - isovalue) < 1e-5)
		return vec1.xyz;
	if (abs(vec2.w - isovalue) < 1e-5)
		return vec2.xyz;
	if (abs(vec1.w - vec2.w) < 1e-5)
		return vec1.xyz;
	
	float interpolant = (isovalue - vec1.w) / (vec2.w - vec1.w);
	interpolant = clamp(interpolant, 0, 1);
	return vec1.xyz + interpolant * (vec2.xyz - vec1.xyz);
}

[numthreads(THREADS_X, THREADS_Y, THREADS_Z)]
void MarchingCubesComputeShader(
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint GroupIndex : SV_GroupIndex )
{
	// Determine which grid cell should be calculated
	uint3 gridCellToBeTriangulated = DispatchThreadId;
	// Check whether this is a valid grid cell and return if not
	if (!IsValidIndex(gridCellToBeTriangulated))
	{
		return;
	}
	
	// Create the gridCell
	FGridCell gridCell;
	for (uint i = 0; i < 8; i++)
	{
		uint3 workingCoordinate = gridCellToBeTriangulated + vertexOrder[i];
		gridCell.positions[i] = zeroNodeOffset + float3(workingCoordinate.x * gridSizePerCube.x, workingCoordinate.y * gridSizePerCube.y, workingCoordinate.z * gridSizePerCube.z);
		gridCell.values[i] = dataGridValues[GetArrayIndex(workingCoordinate)];
	}
	
	// Calculate the unique cube index
    uint cubeIndex = CalculateCubeIndex(gridCell);
	
	// Check if the cube configuration requires any triangles
    if (edgeTable[cubeIndex] == 0)
        return;
	
	// Interpolate the required vertices
	
	
	bool isCreatingTriangle = true;
	if (isCreatingTriangle)
	{
		uint designatedIndex;
		InterlockedAdd(vertexTripletIndex, 3, designatedIndex);
		outputVertexTriplets[designatedIndex] = float3(0, 0, 0);
		outputVertexTriplets[designatedIndex + 1] = float3(0, 100, 0);
		outputVertexTriplets[designatedIndex + 2] = float3(100, 100, 0);
	}
}

